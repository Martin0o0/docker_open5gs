#
# TelcoSuite (V3) Proxy-CSCF
#
# Kamailio (OpenSER) SIP Server
#     - web: http://www.kamailio.org
#     - git: http://sip-router.org
#
# Refer to the Core CookBook at http://www.kamailio.org/dokuwiki/doku.php
# for an explanation of possible statements, functions and parameters.
#

import_file "pcscf.cfg"

####### Defined Values #########
# *** Value defines - IDs used later in config
#!define DISPATCHER_LIST_SBC 1

#!define DISPATCHER_DST_AVP "i:1"
#!define DISPATCHER_GRP_AVP "i:2"
#!define DISPATCHER_CNT_AVP "i:3"
#!define DISPATCHER_SOCK_AVP "i:4"

#!define RR_CUSTOM_USER_AVP "i:5"
#!define DLG_TIMEOUT_AVP "i:6"

#!define FLT_MOBILE_ORIG 1
#!define FLT_DIALOG 2
#!define FLT_NAT 3
#!define FLT_RTP 4
#!define FLT_CAPTURE 5

####### Global Parameters #########

#!ifdef WITH_DEBUG
debug=4
log_stderror=yes
#!else
debug=2
log_stderror=no
#!endif

memdbg=5
memlog=5

max_while_loops=5000

#!ifdef WITH_XMLRPC
listen=tcp:127.0.0.1:5060
#!endif

# Locks all ser pages into memory making it unswappable (in general one 
# doesn't want his sip proxy swapped out )
mlock_pages=yes
# Tries to pre-fault all the shared memory, before starting. When "on", start 
# time will increase, but combined with mlock_pages will guarantee ser will get 
# all its memory from the beginning (no more kswapd slow downs)
shm_force_alloc=yes

# Do SRV-Loadbalancing:
dns_srv_lb=on
# Always prefer IPv6:
dns_try_ipv6=on
# Always prefer IPv6:
dns_cache_flags=4
# DNS-Based failover
use_dns_failover=on
# Query NAPTR-Records as well:
dns_try_naptr=off
# DNS cache won't be used (all dns lookups will result into a DNS request)
use_dns_cache=off

user_agent_header="User-Agent: TelcoSuite Proxy-CSCF"
server_header="Server: TelcoSuite Proxy-CSCF"

log_facility=LOG_LOCAL0

fork=yes
children=4

#!ifndef TCP_PROCESSES
# Number of TCP Processes
#!define TCP_PROCESSES 16
#!endif

#!ifdef WITH_TLS
# Check, if TCP is enabled:
#!ifndef WITH_TCP
#!define WITH_TCP
#!endif
enable_tls=yes
#!endif

#!ifdef WITH_XMLRPC
#!ifndef WITH_TCP
#!define WITH_TCP
#!endif
#!ifndef TCP_PROCESSES
# Number of TCP Processes
#!define TCP_PROCESSES 3
#!endif
#!endif

#!ifdef WITH_TCP
# life time of TCP connection when there is no traffic
# - a bit higher than registration expires to cope with UA behind NAT
tcp_connection_lifetime=36000
# If a message received over a tcp connection has "alias" in its via a new tcp
# alias port will be created for the connection the message came from (the
# alias port will be set to the via one).
#
# Note: For NAT traversal of TCP clients it is better to not use 
# tcp_accept_aliases but just use nathelper module and 
# fix_nated_[contact|register] functions. 
tcp_accept_aliases=no
# Enable SIP outbound TCP keep-alive using PING-PONG (CRLFCRLF - CRLF).
tcp_crlf_ping=yes

tcp_reuse_port=yes

tcp_accept_no_cl=yes
tcp_rd_buf_size=16384

#!ifdef TCP_PROCESSES
tcp_children=TCP_PROCESSES
#!endif
#!else
disable_tcp=yes
#!endif

/* uncomment the next line to disable the auto discovery of local aliases
   based on reverse DNS on IPs (default on) */
auto_aliases=no

#phone2tel=1

udp_mtu = 1300
udp_mtu_try_proto = TCP

/* uncomment and configure the following line if you want Kamailio to 
   bind on a specific interface/port/proto (default bind on all available) */

system.shutdownmode = 0 desc "System shutdown mode"
system.service = "Proxy-CSCF" desc "Function of this server"

####### Modules Section ########

# set paths to location of modules
mpath="/usr/lib64/kamailio/modules_k/:/usr/lib64/kamailio/modules/:/usr/lib/kamailio/modules_k/:/usr/lib/kamailio/modules/:/usr/lib/x86_64-linux-gnu/kamailio/modules/:/usr/local/lib64/kamailio/modules"

# Fifo Module
# Kamailio Extensions (e.g. MI:uptime, MI:version, cfg:isflagset etc.)
loadmodule "kex"
# Transaction Module
loadmodule "tm"
loadmodule "tmx"
loadmodule "sl"
loadmodule "rr"
loadmodule "pv"
loadmodule "maxfwd"
loadmodule "textops"
loadmodule "textopsx"
# SIP-Utilities: options_reply
loadmodule "siputils"
loadmodule "sanity"
loadmodule "ctl"
loadmodule "cfg_rpc"
loadmodule "xlog"
loadmodule "auth"
loadmodule "dispatcher"
loadmodule "sctp"
loadmodule "path"
loadmodule "statistics"

loadmodule "ims_dialog"
loadmodule "ims_usrloc_pcscf"
# Following module is required even in case of IPSec being disabled.
loadmodule "ims_ipsec_pcscf"
loadmodule "ims_registrar_pcscf"

#!ifdef WITH_XMLRPC
loadmodule "xmlrpc"
#!endif

#!ifdef WITH_REGINFO
loadmodule "pua"
#!endif

#!ifdef DB_URL
loadmodule "db_mysql"
#!ifdef DB_URL2
loadmodule "db_cluster"
#!endif
#!endif

#!ifdef WITH_DEBUG
loadmodule "debugger"
#!endif

loadmodule "usrloc"
loadmodule "registrar"

loadmodule "nathelper"

#!ifdef WITH_ANTIFLOOD
#loadmodule "pike"
#!endif

#!ifdef WITH_TLS
loadmodule "tls"
#!endif

#!ifdef WITH_RTPPING
loadmodule "rtpping"
#!endif


loadmodule "sdpops"
loadmodule "rtpengine"

#!ifdef WITH_WEBSOCKET
loadmodule "xhttp.so"
loadmodule "websocket.so"
#!endif

#!ifdef WITH_RX
loadmodule "cdp"
loadmodule "cdp_avp"
loadmodule "ims_qos"
#!endif

#!ifdef WITH_N5
loadmodule "http_async_client"
loadmodule "http_client"
loadmodule "jansson"
loadmodule "nghttp2"
loadmodule "uuid"
#!endif

#!ifdef CAPTURE_NODE
loadmodule "siptrace"
#!endif

#!ifdef WITH_NATPING
loadmodule "rtimer"
loadmodule "uac"
loadmodule "sqlops"
#!endif

# HTable as a cache:
loadmodule "htable"

#!ifdef WITH_DEBUG
#loadmodule "debugger.so"
modparam("debugger", "mod_hash_size", 5)
modparam("debugger", "mod_level_mode", 1)
modparam("debugger", "mod_level", "rtpengine=3")
modparam("debugger", "mod_level", "ims_qos=3")
#!ifdef WITH_IPSEC
modparam("debugger", "mod_level", "ims_ipsec_pcscf=3")
#!endif
modparam("debugger", "mod_level", "textops=3")
modparam("debugger", "mod_level", "tm=3")
modparam("debugger", "mod_level", "ims_registrar_pcscf=3")
modparam("debugger", "mod_level", "ims_usrloc_pcscf=3")
modparam("debugger", "cfgtrace", 1)
#!endif

loadmodule "jsonrpcs.so"
# ----- jsonrpcs params -----
modparam("jsonrpcs", "pretty_format", 1)
/* set the path to RPC fifo control file */
modparam("jsonrpcs", "fifo_name", "/var/run/kamailio/kamailio_rpc.fifo")
/* set the path to RPC unix socket control file */
modparam("jsonrpcs", "dgram_socket", "/var/run/kamailio/kamailio_rpc.sock")

# ----------------- setting module-specific parameters ---------------
#!ifdef DB_URL2
# ----- db_cluster params -----
modparam("db_cluster", "connection", DB_URL)
modparam("db_cluster", "connection", DB_URL2)
modparam("db_cluster", "cluster", "cluster1=>con1=2s2s;con2=1s1s")
#!endif

#!ifdef WITH_ANTIFLOOD
# ----- pike params -----
#modparam("pike", "sampling_time_unit", 2)
#modparam("pike", "reqs_density_per_unit", 16)
#modparam("pike", "remove_latency", 4)

# ----- htable params -----
# ip ban htable with autoexpire after 5 minutes
; modparam("htable", "htable", "ipban=>size=8;autoexpire=300")
; modparam("htable", "htable", "failedauth=>size=8;autoexpire=120")
modparam("htable", "htable", "natpingfrom=>size=8;autoexpire=600000;")
#!endif

modparam("htable", "htable", "contact=>size=8;autoexpire=20")
modparam("htable", "htable", "a=>size=8;autoexpire=20")

#!ifdef WITH_IMS_HDR_CACHE
modparam("htable", "htable", "serviceroutes=>size=16;autoexpire=14400;")
modparam("htable", "htable", "associateduris=>size=16;autoexpire=14400;")
#!endif

#!ifdef WITH_NATPING
modparam("htable", "htable", "natping=>size=8;autoexpire=600000;")
modparam("htable", "htable", "natpingfail=>size=8;autoexpire=600000;")
modparam("htable", "htable", "natpingfrom=>size=8;autoexpire=600000;")
#!ifdef DB_URL2
modparam("sqlops","sqlcon","pcscf=>cluster://cluster1")
#!else
modparam("sqlops","sqlcon", SQLOPS_DBURL)
#!endif

modparam("uac","restore_mode","none")

# ----------------- Settings for RTimer ---------------
# time interval set to 60 seconds
modparam("rtimer", "timer", "name=NATPING;interval=5;mode=1;")
modparam("rtimer", "exec", "timer=NATPING;route=NATPING")
#!endif

# ----- tm params -----
# auto-discard branches from previous serial forking leg
#modparam("tm", "failure_reply_mode", 3)
# default retransmission timeout: 3 sec
modparam("tm", "fr_timer", 3000)
# default invite retransmission timeout after 1xx: 120sec
modparam("tm", "fr_inv_timer", 120000)
# Dont reply automatically with "100 Trying"
modparam("tm", "auto_inv_100", 0)

# ----- rr params -----
# add value to ;lr param to cope with most of the UAs
modparam("rr", "enable_full_lr", 1)
# do not append from tag to the RR (no need for this script)
modparam("rr", "append_fromtag", 1)
# add a Username to RR-Header
modparam("rr", "add_username", 1)
# Take User from a custom AVP
modparam("rr", "custom_user_avp", "$avp(RR_CUSTOM_USER_AVP)")
modparam("rr", "force_send_socket", 1)

#!ifdef WITH_XMLRPC
# ----- xmlrpc params -----
modparam("xmlrpc", "route", "XMLRPC");
modparam("xmlrpc", "url_match", "^/RPC")
#!endif

#!ifdef WITH_TLS
# ----- tls params -----
modparam("tls", "config", "/etc/kamailio_pcscf/tls.cfg")
#!endif

# ----- rtpproxy params -----
modparam("rtpengine", "setid_default", 1)
modparam("rtpengine", "rtpengine_sock", "1 == udp:RTPENGINE_IP:2223")
#modparam("rtpengine", "rtpengine_sock", "2 == udp:localhost:2224")
modparam("rtpengine", "setid_avp", "$avp(setid)")
modparam("rtpengine", "extra_id_pv", "$avp(extra_id)")

modparam("path", "use_received", 1)

# ----- ctl params -----
modparam("ctl", "binrpc", "unix:/var/run/kamailio/kamailio_ctl")

# ----------------- Settings for Dispatcher ---------------
modparam("dispatcher", "list_file", "/etc/kamailio_pcscf/dispatcher.list")

# Dispatcher: Enable Failover-Support
modparam("dispatcher", "flags", 2)
# Dispatcher: Overwrite Destination address, if required.
modparam("dispatcher", "force_dst", 1)
# AVP's required for Fail-Over-Support:
#modparam("dispatcher", "dst_avp", "$avp(DISPATCHER_DST_AVP)")
#modparam("dispatcher", "grp_avp", "$avp(DISPATCHER_GRP_AVP)")
#modparam("dispatcher", "cnt_avp", "$avp(DISPATCHER_CNT_AVP)")
#modparam("dispatcher", "sock_avp", "$avp(DISPATCHER_SOCK_AVP)")

#modparam("dispatcher", "xavp_dst", "$avp(DISPATCHER_DST_AVP)")
#modparam("dispatcher", "xavp_dst_mode", 0)
#modparam("dispatcher", "xavp_ctx", "$avp(DISPATCHER_CNT_AVP)")
#modparam("dispatcher", "xavp_ctx_mode", 0)

# Try to recover disabled destinations every 15 seconds.
modparam("dispatcher", "ds_ping_interval", 15)
# Actively query the gateways:
modparam("dispatcher", "ds_probing_mode", 1)

# -- usrloc params --
#!ifdef DB_URL
#!ifdef DB_URL2
modparam("ims_usrloc_pcscf", "db_url", "cluster://cluster1")
#!else
modparam("ims_usrloc_pcscf", "db_url", DB_URL)
#!endif
modparam("ims_usrloc_pcscf", "db_mode", 0)
#!endif
#modparam("ims_usrloc_pcscf", "hashing_type", 2)
modparam("ims_usrloc_pcscf", "enable_debug_file", 0)
modparam("ims_usrloc_pcscf", "match_contact_host_port", 1)
modparam("ims_registrar_pcscf", "is_registered_fallback2ip", 1)
modparam("ims_registrar_pcscf", "ignore_reg_state", 1)
modparam("ims_registrar_pcscf", "ignore_contact_rxport_check", 1)
modparam("ims_registrar_pcscf", "pending_reg_expires", 30)
modparam("ims_registrar_pcscf", "subscription_expires", 36000)
modparam("ims_registrar_pcscf", "delete_delay", CONTACT_DELETE_DELAY)
modparam("ims_usrloc_pcscf", "expires_grace", 120)

#!ifdef WITH_REGINFO
modparam("ims_registrar_pcscf", "subscribe_to_reginfo", 1)
modparam("ims_registrar_pcscf", "publish_reginfo", 1)
modparam("ims_registrar_pcscf", "pcscf_uri", "sip:HOSTNAME")
#!else
modparam("ims_registrar_pcscf", "subscribe_to_reginfo", 0)
modparam("ims_registrar_pcscf", "publish_reginfo", 0)
#!endif

#!ifdef WITH_IPSEC
modparam("ims_ipsec_pcscf", "ipsec_listen_addr", IPSEC_LISTEN_ADDR)
modparam("ims_ipsec_pcscf", "ipsec_client_port", IPSEC_CLIENT_PORT)
modparam("ims_ipsec_pcscf", "ipsec_server_port", IPSEC_SERVER_PORT)
modparam("ims_ipsec_pcscf", "ipsec_spi_id_start", 4096)
modparam("ims_ipsec_pcscf", "ipsec_max_connections", IPSEC_MAX_CONN)
modparam("ims_ipsec_pcscf", "ipsec_preferred_ealg", "null")
modparam("htable", "htable", "ipsec_clients=>size=8;autoexpire=600000;")
#!endif

#!ifdef WITH_RX
# -- CDP params --
modparam("cdp","config_file","/etc/kamailio_pcscf/pcscf.xml")
# -- diameter_rx params --
modparam("ims_qos", "rx_dest_realm", "PCRF_REALM")
modparam("ims_qos", "early_qosrelease_reason", "Sorry - QoS failed")
modparam("ims_qos", "confirmed_qosrelease_headers", "X-Reason: QoS failed\r\n")
modparam("ims_qos", "authorize_video_flow", 1)
modparam("ims_qos", "af_signaling_ip", RX_AF_SIGNALING_IP)
modparam("ims_qos", "include_rtcp_fd", 1)
modparam("ims_qos", "rx_auth_expiry", 36000)
modparam("ims_qos", "recv_mode", 1)
modparam("ims_qos", "dialog_direction", RX_IMS_REG_DIALOG_DIRECTION)
#!endif

#!ifdef WITH_N5
modparam("http_client", "httpredirect", 1)
modparam("http_client", "useragent", "PCSCF")
modparam("http_client", "maxdatasize", 64535)
modparam("http_client", "connection_timeout", 2)
modparam("http_client", "keep_connections", 1)
modparam("http_client", "response_headers", 1)
modparam("nghttp2", "listen_addr", "N5_BIND_IP")
modparam("nghttp2", "listen_port", "N5_BIND_PORT")

modparam("rtimer", "timer", "name=NRF_NFM;interval=5;mode=1;")
modparam("rtimer", "exec", "timer=NRF_NFM;route=NRF_NFM")
#!endif

# -- pua params --
#!ifdef WITH_REGINFO
#!ifdef DB_URL
#!ifdef DB_URL2
modparam("pua", "db_url", "cluster://cluster1")
#!else
modparam("pua", "db_url", DB_URL)
#!endif
#!endif
#!endif

# -- ims_dialog params --
modparam("ims_dialog", "dlg_flag", FLT_DIALOG)
modparam("ims_dialog", "timeout_avp", "$avp(DLG_TIMEOUT_AVP)")
modparam("ims_dialog", "detect_spirals", 0)
modparam("ims_dialog", "profiles_no_value", "orig ; term")
modparam("ims_dialog", "profiles_with_value", "caller ; callee")
#!ifdef DB_URL
#!ifdef DB_URL2
modparam("ims_dialog", "db_url", "cluster://cluster1")
#!else
modparam("ims_dialog", "db_url", DB_URL)
#!endif
modparam("ims_dialog", "db_mode", 0)
#!endif

#!ifdef CAPTURE_NODE
# Destination, where to send the traffic
modparam("siptrace", "duplicate_uri", CAPTURE_NODE)
# Trace all traffic
modparam("siptrace", "trace_on", 1)
modparam("siptrace", "trace_to_database", 0)
modparam("siptrace", "trace_flag", FLT_CAPTURE)
modparam("siptrace", "hep_mode_on", 1)
#!endif

# -- statistics params --
modparam("statistics", "variable", "register_success")
modparam("statistics", "variable", "register_failed")
modparam("statistics", "variable", "register_time")


####### Routing Logic ########

# Main SIP request routing logic
# - processing of any incoming SIP request starts with this route
route {
##!ifdef WITH_DEBUG
	xnotice("PCSCF: $rm $ru ($fu ($si:$sp) to $tu, $ci)\n");
##!endif

#!ifdef WITH_WEBSOCKET
	if (($Rp == MY_WS_PORT || $Rp == MY_WSS_PORT) && !(proto == WS || proto == WSS)) {
		xlog("L_WARN", "Websocket-request received on SIP/$Rp\n");
		sl_send_reply("403", "Forbidden - Websocket-request received on SIP/$Rp");
		exit;
	}
#!endif
	# per request initial checks
	route(REQINIT);

	# CANCEL processing
	if (is_method("CANCEL")) {
		if (t_check_trans()) {
			t_relay();
		}
		exit;
	}

	if (is_method("NOTIFY") && (uri==myself)) {
		route(NOTIFY);
		exit;
	}

	# handle retransmissions
	if (!is_method("ACK")) {
		if(t_precheck_trans()) {
			t_check_trans();
			exit;
		}
	}
	#t_check_trans();

	# Check for Re-Transmissions
	t_check_trans();

	# handle requests within SIP dialogs
	route(WITHINDLG);

	### only initial requests (no To tag)

	if (is_method("UPDATE")) {
		send_reply("403","Forbidden - Target refresh outside dialog not allowed");
		break;
	}
	if (is_method("BYE|PRACK")) {
		send_reply("403","Forbidden - Originating subsequent requests outside dialog not allowed");
		break;
	}

	#Set DLG flag to track dialogs using dialog2
	if (!is_method("REGISTER|SUBSCRIBE"))
		setflag(FLT_DIALOG);

	loose_route();
#!ifdef WITH_SBC
	if (ds_is_from_list(DISPATCHER_LIST_SBC)) {
		if (is_method("INVITE")) {
			if (is_present_hf("C-Params")) {
				remove_hf("Contact");
				remove_hf("C-Params");
				append_hf("Contact: $ct;$hdr(C-Params)\r\n");
			}
			if ($route_uri =~ "sip:mo@.*") {
				# prepend mo as user for record route
				$avp(RR_CUSTOM_USER_AVP)="mo";
				if (is_present_hf("P-Route")) {
					$du = $(hdr(P-Route){nameaddr.uri});
					remove_hf("P-Route");
					append_hf("Route: $hdr(P-Route)\r\n");
				}
				t_on_reply("SBC_GET_CPARAMS");
			}
			if ($route_uri =~ "sip:mt@.*") {
				$du = $ru;
				handle_ruri_alias();
				if ($rc == 1) {
					setflag(FLT_NAT);
				}
				xlog("$$dP => $(dP{s.tolower}) ($du)\n");
				# prepend mo as user for record route
				$avp(RR_CUSTOM_USER_AVP)="mt";
				if ($(dP{s.tolower}) == "tls") {
					route(ENC_SRTP);
				} else if ($(dP{s.tolower}) == "ws") {
					# Even WSS is incorrectly shown as WS
					route(ENC_WSS_RTP);
				} else if ($(dP{s.tolower}) == "wss") {
					route(ENC_WSS_RTP);
				} else {
					route(ENC_RTP);
				}
				# Handle NAT
				route(NATMANAGE);
				# Handle Mobile Terminated requests
				route(MT);
			}
		}
		if (is_method("REGISTER")) {
			append_hf("Path: <sip:term@$Ri:$Rp;lr>\r\n");
		}
	} else {
#!endif
		if ($route_uri =~ "sip:term@.*") {
#!ifdef WITH_SBC
#!ifdef WITH_SBC_CALL
			if (is_method("INVITE")) {
#!endif
				if (!strempty($(ct{tobody.params}))) {
					append_hf("C-Params: $(ct{tobody.params})\r\n");
				}

				append_hf("SBC: mt\r\n");
				# Do some Round-Robin on the SBC's
				t_on_failure("SBC_failure");
				# Choose an SBC to send the call to:
				if (!ds_select_dst(DISPATCHER_LIST_SBC, "4")) {
					send_reply("503", "Service Unavailable (SBC failure)");
					exit;
				}
#!ifdef WITH_SBC_CALL
			}
#!endif
#!else
			handle_ruri_alias();
			if ($dP == "tls") {
				route(ENC_SRTP);
			} else if ($dP == "ws") {
				route(ENC_WS_RTP);
			} else if ($dP == "wss") {
				route(ENC_WSS_RTP);
			} else {
				route(ENC_RTP);
			}
			if ($rc == 1) {
				setflag(FLT_NAT);
			}
			# Handle NAT
			route(NATMANAGE);
			# prepend mo as user for record route
			$avp(RR_CUSTOM_USER_AVP)="mt";
			route(MT);
#!endif
		} else {
			force_rport();
			if(is_method("INVITE|SUBSCRIBE|UPDATE|REGISTER")) {
				add_contact_alias();
			}
			setflag(FLT_NAT);

			if (is_method("REGISTER")) {
				route(REGISTER);
				exit;
			}

			# prepend mo as user for record route
			$avp(RR_CUSTOM_USER_AVP)="mo";
			# Set Flag for MO:
			setflag(FLT_MOBILE_ORIG);
			# Increase timer for inbound requests, we may have to do failover:
			t_set_fr(120000, 30000);
			route(MO);
			if (is_method("INVITE")) {
				# SRTP in RTP übersetzen
				if ($pr == "tls") {
					route(DEC_SRTP);
				} else if ($pr == "ws") {
					route(DEC_WS_RTP);
				} else if ($pr == "wss") {
					route(DEC_WSS_RTP);
				} else {
					route(DEC_RTP);
				}
				# Handle NAT
				route(NATMANAGE);
			}
#!ifdef WITH_SBC
#!ifdef WITH_SBC_CALL
			if (is_method("INVITE")) {
#!endif
				# Apply changes to this message
				msg_apply_changes();
				# Copy Route-Header:
				append_hf("P-Route: $hdr(Route)\r\n");
				if (!strempty($(ct{tobody.params}))) {
					append_hf("C-Params: $(ct{tobody.params})\r\n");
				}
				append_hf("SBC: mo\r\n");
				# Do some Round-Robin on the SBC's
				t_on_failure("SBC_failure");
				# Choose an SBC to send the call to:
				if (!ds_select_dst(DISPATCHER_LIST_SBC, "4")) {
					send_reply("503", "Service Unavailable (SBC failure)");
					exit;
				}
#!endif
#!ifdef WITH_SBC_CALL
			}
#!endif
		}
#!ifdef WITH_SBC
	}
#!endif
	if (is_method("INVITE|SUBSCRIBE")) {
		# record routing for dialog forming requests (in case they are routed)
		record_route();
	}

	# Forward request:
	route(RELAY);
	exit;
}

route[SBC_GET_CPARAMS] {
	if (!strempty($(ct{tobody.params}))) {
		append_hf("C-Params: $(ct{tobody.params})\r\n");
	}
}

# Per SIP request initial checks
route[REQINIT] {
	# Reply to OPTIONS:
	if (is_method("OPTIONS") && (uri==myself)) {
		options_reply();
		exit;
	}

	$var(used) = 1 - ($stat(free_size) / $stat(total_size));
	xlog("L_DBG", "Mem: Total $stat(total_size), Free $stat(free_size) [$var(used)% used]\n");
	if ($var(used) > 95) {
		send_reply("503", "Server overloaded");
		exit;
	}

	# Trace this message
#!ifdef CAPTURE_NODE
	sip_trace();
	setflag(FLT_CAPTURE);
#!endif

#!ifdef WITH_ANTIFLOOD
	# flood dection from same IP and traffic ban for a while
	# be sure you exclude checking trusted peers, such as pstn gateways
	# - local host excluded (e.g., loop to self)
	#if (!has_totag() && (src_ip!=myself) && !ds_is_from_list())
	#{
	#	if($sht(ipban=>$si)!=$null)
	#	{
	#		# ip is already blocked
	#		xlog("request from blocked IP - $rm from $fu (IP:$si:$sp)\n");
	#		xlog("Blocking traffic from $si\n");
	#		exit;
	#	}
	#	if (!pike_check_req()) {
	#		xlog("L_ALERT","ALERT: pike blocking $rm from $fu (IP:$si:$sp, $ua)\n");
	#		xlog("Blocking traffic from $si\n");
	#		$sht(ipban=>$si) = 1;
	#		exit;
	#	}
	#}
    #    if ((uri == myself) && is_method("INVITE|REGISTER")) {
    #            xlog("L_ALERT","ALERT: Request to myself: $ru from $fu (IP:$si:$sp, $ua), Blocking\n");
#		xlog("Blocking traffic from $si\n");
#                $sht(ipban=>$si) = 1;
#                exit;
#        }
#!endif

	if (!mf_process_maxfwd_header("10")) {
		sl_send_reply("483","Too Many Hops");
		exit;
	}

	if(!sanity_check("1511", "7")) {
		xlog("Malformed SIP message from $si:$sp\n");
		exit;
	}

	# Check for shutdown mode:
	if (!has_totag() && ($sel(cfg_get.system.shutdownmode) > 0)) {
		send_reply("503", "Server shutting down");
		exit;
	}

	# Ignore Re-Transmits:
	if (t_lookup_request()) {
		exit;
	}

	if (is_method("INVITE|REGISTER")) {
		send_reply("100", "Trying");
	}
}

route[RELAY] {
	if (!t_relay()) {
		sl_reply_error();
	}
	exit;
}

# Handle requests within SIP dialogs
route[WITHINDLG] {
	if (has_totag()) {
		xnotice("Within DLG\n");
		# sequential request withing a dialog should
		# take the path determined by record-routing
		if (loose_route()) {
			xnotice("Within loose route\n");
			if(!isdsturiset()) {
				handle_ruri_alias();
				#if ($rc == 1) {
				#	$ru = "sip:" + $rU + "@" + $dd + ":" + $dp + ";transport=" + $rP;
				#}
			}

			if ( is_method("ACK") && ($sht(contact=>$ci) != $null) ) {
				xlog("Contact of Reply: $sht(contact=>$ci) ($ci)\n");
				$ru = $sht(contact=>$ci);
			}

			if ($route_uri =~ "sip:mt@.*") {
				route(MT_indialog);
			} else {
				route(MO_indialog);
			}

			# Handle NAT
			route(NATMANAGE);

			route(RELAY);
			exit;
		}
		if ( is_method("ACK") ) {
			xlog("Contact of Reply: $T_rpl($ct)\n");
			if ( t_check_trans() ) {
				# no loose-route, but stateful ACK;
				# must be an ACK after a 487
				# or e.g. 404 from upstream server
				t_relay();
				exit;
			} else {
				# ACK without matching transaction ... ignore and discard
				exit;
			}
		}
		sl_send_reply("404","Not here");
		exit;
	}
}

######################################################################
# Negative replies to REGISTER requests:
######################################################################
failure_route[SBC_failure] {
#!ifdef WITH_IPBLOCK
	if (is_method("REGISTER") && !ds_is_from_list()) {
		if (t_check_status("403|[5-6][0-9][0-9]")) {
			if ($sht(failedauth=>$si) != $null)
				$sht(failedauth=>$si) = $sht(failedauth=>$si) + 1;
			else
				$sht(failedauth=>$si) = 1;
			if ($sht(failedauth=>$si) > 10) {
				xlog("L_ALERT","ALERT: blocking $rm from $fu (IP:$si:$sp), more than 5 failed auth requests!\n");
				xlog("Blocking traffic from $si\n");
				$sht(ipban=>$si) = 1;
			}
		}
	}
#!endif
	# Choose another gateway, in case we
	# - get a local generated "408"
	# - receive a 5xx or 6xx reply from the proxy.
	if (t_branch_timeout() || t_check_status("[5-6]..")) {
		if (ds_next_dst()) {
			# Do Failover in case problems:
			t_on_failure("SBC_failure");
			t_relay();
		} else {
			# Add a header, to indicate the phone should try again in 30 seconds.
			append_hf("Retry-After: 30\r\n");
			send_reply("504", "Server Time-Out");
		}
		exit;
	}
}

# Notify Route:                                                     #
#####################################################################
route[NOTIFY]
{
	xlog("L_DBG", "IMS: INSIDE NOTIFY\n");
	if (reginfo_handle_notify("location")) {
		send_reply("200","OK - P-CSCF processed notification");
		break;
	} else {
		t_reply("500","Error encountered while processing notification");
		break;
	}
}

#!ifdef WITH_NATPING
# NATPING Route:                                                    #
#####################################################################
route[NATPING] {
	route(preload_pcscf);

	sht_lock("natping=>natpinglock");
	sht_iterator_start("nat_iterator", "natping");
	while(sht_iterator_next("nat_iterator")) {
		xnotice("OPTIONS to $shtitval(nat_iterator) via $shtitkey(nat_iterator)...\n");
		$uac_req(method) = "OPTIONS";
		$uac_req(ruri) = $shtitval(nat_iterator);
		$uac_req(furi) = PCSCF_URL;
		$uac_req(sock) = $sht(natpingfrom=>$shtitkey(nat_iterator));
		$uac_req(turi) = $shtitval(nat_iterator);
		$uac_req(ouri) = $shtitkey(nat_iterator);
		$uac_req(evroute) = 1;
		uac_req_send();
	}
	sht_iterator_end("nat_iterator");
	sht_unlock("natping=>natpinglock");
}

event_route[uac:reply] {
##!ifdef WITH_DEBUG
	xnotice("request sent to $uac_req(ruri) completed with code: $uac_req(evcode), Type $uac_req(evtype)\n");
##!endif
	if (($uac_req(evtype) != 1) || ($uac_req(evcode) != 200)) {
		if ($sht(natpingfail=>$uac_req(ouri)) == $null) {
			$sht(natpingfail=>$uac_req(ouri)) = 1;
		} else {
			$sht(natpingfail=>$uac_req(ouri)) = $sht(natpingfail=>$uac_req(ouri)) + 1;
		}
		xlog("  request sent to $uac_req(ruri): Fail Counter is $sht(natpingfail=>$uac_req(ouri))\n");
		if ($sht(natpingfail=>$uac_req(ouri)) > 10) {
			if ($(uac_req(ouri){uri.transport}) == "tcp") {
				$var(alias) = "alias="+$(uac_req(ouri){uri.host})+"~"+$(uac_req(ouri){uri.port})+"~2";
			} else if ($(uac_req(ouri){uri.transport}) == "tls") {
				$var(alias) = "alias="+$(uac_req(ouri){uri.host})+"~"+$(uac_req(ouri){uri.port})+"~3";
			} else {
				$var(alias) = "alias="+$(uac_req(ouri){uri.host})+"~"+$(uac_req(ouri){uri.port})+"~1";
			}
			xlog("  Unregistering $uac_req(ruri);$var(alias)\n");
			setdebug("9");
#!ifdef WITH_IPSEC
			ipsec_destroy_by_contact("location", "$uac_req(ruri);$var(alias)", "$(uac_req(ouri){uri.host})", "$(uac_req(ouri){uri.port})");
#!endif
			pcscf_unregister("location", "$uac_req(ruri);$var(alias)", "$(uac_req(ouri){uri.host})", "$(uac_req(ouri){uri.port})");
			resetdebug();
			sht_lock("natping=>natpinglock");
			$sht(natping=>$uac_req(ouri)) = $null;
			sht_unlock("natping=>natpinglock");
			$sht(natpingfail=>$uac_req(ouri)) = $null;

			sht_lock("natpingfrom=>natpingfromlock");
			$sht(natpingfrom=>$uac_req(ouri)) = $null;
			sht_unlock("natpingfrom=>natpingfromlock");
			$sht(natpingfail=>$uac_req(ouri)) = $null;
		}
	} else {
		$sht(natpingfail=>$uac_req(ouri)) = $null;
	}
}

event_route[htable:expired:natping] {
    xlog("natping record expired $shtrecord(key) => $shtrecord(value)\n");
}

event_route[htable:mod-init] {
	xlog("event_route[htable:mod-init] \n");
}

route[preload_pcscf] {
	if ($shv(preload_pcscf) == 1) return;
	$shv(preload_pcscf) = 1;

	sql_query("pcscf", "select aor, received, received_port, received_proto from location;", "resultset");
	xlog("L_INFO", "Preloading NAT-PING. Rows: $dbr(resultset=>rows)\n");
	if($dbr(resultset=>rows)>0) {
		$var(i) = 0;
		while($var(i) < $dbr(resultset=>rows)) {
			$var(ouri) = "sip:"+$dbr(resultset=>[$var(i),1])+":"+$dbr(resultset=>[$var(i),2]);
			if ($dbr(resultset=>[$var(i),3]) == 2) {
				$var(ouri) = $var(ouri)+";transport=tcp";
			} else if ($dbr(resultset=>[$var(i),3]) == 3) {
				$var(ouri) = $var(ouri)+";transport=tls";
			}
			$var(noalias) = $(dbr(resultset=>[$var(i),0]){re.subst,/^(.*);alias=.*/\1/}{nameaddr.uri});
			# xlog("$$var(noalias) => $var(noalias) (via $var(ouri))\n");
			sht_lock("natping=>natpinglock");
			$sht(natping=>$var(ouri)) = $var(noalias);
			sht_unlock("natping=>natpinglock");
			$var(i) = $var(i) + 1;
		}
	}
	sql_result_free("resultset");
}
#!endif

#!ifdef WITH_N5
event_route[nghttp2:request] {
	xinfo("request: $nghttp2(method) - url: $nghttp2(path) - data: [$nghttp2(data)]\n");

    // Check if the requested URL is /nf-status-notify
    if ($nghttp2(path) == "/nf-status-notify") {
        nghttp2_reply_header("Content-Type", "text/html");
        nghttp2_reply_header("Server:", "PCSCF");
        nghttp2_reply("200", "<html><body>PCF registered at PCSCF</body></html>");
    } else {
        // Optionally handle other URLs or do nothing
        nghttp2_reply("404", "<html><body>Not Found</body></html>");
    }
}

route[NRF_NFM] {
	if ($var(n5_hb_fail_count) > 5) {
		xlog("L_ERR", "PCSCF NF no longer registered at SCP. Re-attempting registration!!\n");
		$var(n5_initalized) = 0;
	}

	$var(time_now) = $_s($timef(%a, %d %b %Y %H:%M:%S %Z));

	# TODO: Send at heartbeat intervals received in reponse to NF registration
	if ($var(n5_initalized) == 1) {
		# Send Heartbeat
		$var(nf_hb_headers) = "content-type: application/json-patch+json\r\n";
		$var(nf_hb_headers) = $var(nf_hb_headers) + "accept: application/json,application/problem+json\r\n";
		$var(nf_hb_headers) = $var(nf_hb_headers) + "3gpp-sbi-discovery-target-nf-type: NRF\r\n";
		$var(nf_hb_headers) = $var(nf_hb_headers) + "3gpp-sbi-max-rsp-time: 10000\r\n";
		$var(nf_hb_headers) = $var(nf_hb_headers) + "3gpp-sbi-discovery-service-names: nnrf-nfm\r\n";
		$var(nf_hb_headers) = $var(nf_hb_headers) + "3gpp-sbi-sender-timestamp: " + $var(time_now);

		$var(nf_hb_json_body) ='[]';
		$var(nf_hb_body) = '{
			"op": "replace",
			"path": "/nfStatus",
			"value": "REGISTERED"
		}';
		jansson_append("obj", "", $var(nf_hb_body), "$var(nf_hb_json_body)");
		$var(nf_hb_body) = '{
			"op": "replace",
			"path": "/load",
			"value": 0
		}';
		jansson_append("obj", "", $var(nf_hb_body), "$var(nf_hb_json_body)");

		http_client_request_v2pk("PATCH", "http://SCP_BIND_IP:SCP_BIND_PORT/nnrf-nfm/v1/nf-instances/$var(pcscf_uuid)", "$var(nf_hb_json_body)", "$var(nf_hb_headers)", "$var(nf_hb_result)");
		switch ($rc) {
			case 204:
				$var(n5_hb_fail_count) = 0;
				break;
			default:
				$var(n5_hb_fail_count) = $var(n5_hb_fail_count) + 1;
				return;
		}
		return;
	}

	# Generate UUID for PCSCF
	$var(pcscf_uuid) = $uuid(g);

	# Register NF
	$var(nf_reg_headers) = "content-type: application/json\r\n";
	$var(nf_reg_headers) = $var(nf_reg_headers) + "accept: application/json,application/problem+json\r\n";
	$var(nf_reg_headers) = $var(nf_reg_headers) + "3gpp-sbi-discovery-target-nf-type: NRF\r\n";
	$var(nf_reg_headers) = $var(nf_reg_headers) + "3gpp-sbi-max-rsp-time: 10000\r\n";
	$var(nf_reg_headers) = $var(nf_reg_headers) + "3gpp-sbi-discovery-service-names: nnrf-nfm\r\n";
	$var(nf_reg_headers) = $var(nf_reg_headers) + "3gpp-sbi-sender-timestamp: " + $var(time_now);

	$var(nf_reg_body) = '{
		"nfInstanceId": "PCSCF_UUID",
		"nfType":   "PCSCF",
		"nfStatus": "REGISTERED",
		"ipv4Addresses": ["N5_BIND_IP"],
		"allowedNfTypes": ["SCP", "PCF"],
		"priority": 0,
		"capacity": 100,
		"load": 0,
		"nfServiceList": {
			"PCSCF_UUID": {
				"serviceInstanceId": "PCSCF_UUID",
				"serviceName": "npcf-policyauthorization",
				"versions": [
					{
						"apiVersionInUri": "v2",
						"apiFullVersion": "2.0.0"
					}
				],
				"scheme": "http",
				"nfServiceStatus": "REGISTERED",
				"ipEndPoints": [
					{
						"ipv4Address": "N5_BIND_IP",
						"port": N5_BIND_PORT
					}
				],
				"allowedNfTypes": [
					"PCF"
				],
				"priority": 0,
				"capacity": 100,
				"load": 0
			}
		},
		"nfProfileChangesSupportInd": true
	}';
	$var(nf_reg_body) = $(var(nf_reg_body){re.subst,/PCSCF_UUID/$var(pcscf_uuid)/g});
	jansson_append("obj", "", "$var(nf_reg_body)", "$var(nf_reg_json_body)");

	http_client_request_v2pk("PUT", "http://SCP_BIND_IP:SCP_BIND_PORT/nnrf-nfm/v1/nf-instances/$var(pcscf_uuid)", "$var(nf_reg_json_body)", "$var(nf_reg_headers)", "$var(nf_reg_result)");
	switch ($rc) {
		case 201:
			xlog("L_INFO", "P-CSCF NF registered successfully at SCP\n");
			$var(n5_initalized) = 1;
			$var(n5_hb_fail_count) = 0;
			route(NRF_NFM_SUBSCRIBE_PCF);
			break;
		default:
			xlog("L_ERR", "P-CSCF NF failed to register at SCP with code=$rc\n");
			return;
	}
}

route[NRF_NFM_SUBSCRIBE_PCF] {
	# Subscribe to PCF NF registration notification
	$var(time_now) = $_s($timef(%a, %d %b %Y %H:%M:%S %Z));
	$var(pcf_subc_headers) = "content-type: application/json\r\n";
	$var(pcf_subc_headers) = $var(pcf_subc_headers) + "accept: application/json,application/problem+json\r\n";
	$var(pcf_subc_headers) = $var(pcf_subc_headers) + "3gpp-sbi-discovery-target-nf-type: NRF\r\n";
	$var(pcf_subc_headers) = $var(pcf_subc_headers) + "3gpp-sbi-callback: Nnrf_NFManagement_NFStatusNotify\r\n";
	$var(pcf_subc_headers) = $var(pcf_subc_headers) + "3gpp-sbi-max-rsp-time: 10000\r\n";
	$var(pcf_subc_headers) = $var(pcf_subc_headers) + "3gpp-sbi-discovery-service-names: nnrf-nfm\r\n";
	$var(pcf_subc_headers) = $var(pcf_subc_headers) + "3gpp-sbi-sender-timestamp: " + $var(time_now);

	$var(pcf_subc_body) = '{
		"nfStatusNotificationUri": "http://N5_BIND_IP:N5_BIND_PORT/nnrf-nfm/v1/nf-status-notify",
		"reqNfInstanceId": "PCSCF_UUID",
		"subscrCond": {
			"nfType": "PCF"
		},
		"reqNfType": "PCSCF",
		"requesterFeatures": "1"
	}';
	$var(pcf_subc_body) = $(var(pcf_subc_body){re.subst,/PCSCF_UUID/$var(pcscf_uuid)/g});
	jansson_append("obj", "", "$var(pcf_subc_body)", "$var(pcf_subc_json_body)");

	http_client_request_v2pk("POST", "http://SCP_BIND_IP:SCP_BIND_PORT/nnrf-nfm/v1/subscriptions", "$var(pcf_subc_json_body)", "$var(pcf_subc_headers)", "$var(pcf_subc_result)");
	switch ($rc) {
		case 201:
			xlog("L_INFO", "P-CSCF NF subscribed for PCF NF registration notification\n");
			break;
		default:
			xlog("L_ERR", "P-CSCF NF failed to subscribe for PCF NF registration notification\n");
			return;
	}
}
#!endif

#!ifdef WITH_XMLRPC
include_file "route/xmlrpc.cfg"
#!endif
#!ifdef WITH_WEBSOCKET
include_file "route/websocket.cfg"
#!endif
######################################################################
# Route for handling Registrations:
######################################################################
route[REGISTER] {
	# Provide some statistics
        if ($sht(a=>$ci::start_time) == $null || $sht(a=>$ci::start_time) == 0) {
            $sht(a=>$ci::start_time) = $TV(Sn);
        }
	xnotice("PCSCF REGISTER: \n Destination URI: $du\n Request URI: $ru\n");
	xnotice("Source IP and Port: ($si:$sp)\n Route-URI: $route_uri\n");
	xnotice("Received IP and Port: ($Ri:$Rp)\n");
	xnotice("Contact header: $ct\n");

	# Strip Transport from RURI:
	$ru = $(ru{re.subst,/;transport=[A-Za-z]*//g});

	if (is_present_hf("Contact")) {
		pcscf_save_pending("location");
	} else {
		send_reply("403", "No contact header");
		exit;
	}

#!ifdef WITH_IPSEC
	$sht(ipsec_clients=>$(ct{nameaddr.uri})) = $null;
	if ($hdr(Security-Client) =~ ".*ipsec-3gpp.*") {
		$sht(ipsec_clients=>$(ct{nameaddr.uri})) = 1;
	}
#!endif

	# Strip additional Tags from RURI:
	if ($rU == $null)
		$ru = "sip:"+$rd;
	else
		$ru = "sip:"+$rU+"@"+$rd;

#!ifdef WITH_RX
	if ($expires(min) != 0) {
		xlog("L_DBG","Subscribing to signalling bearer status\n");

		Rx_AAR_Register("REG_AAR_REPLY", "location");
		switch ($retcode) {
			case -1:
				# There was an error sending the AAR-Request:
				xlog("L_ERR", "Diameter: AAR failed on subscription to signalling\n");
				send_reply("403", "Can't register to QoS for signalling");
				exit;
				break;
			case 0:
				# We are waiting for an async reply, just exit here.
				exit;
				break;
			case 1:
				# We did not need to send AAR, so just continue as normal
				route(REGISTER_CONTINUE);
				break;
		}
	} else {
		# Proceed with Registering:
		route(REGISTER_CONTINUE);
	}
	exit;
}

route[REG_AAR_REPLY] {
	switch ($avp(s:aar_return_code)) {
		case 1:
			xlog("L_DBG", "Diameter: AAR success on subscription to signalling\n");
			break;
		default:
			xlog("L_ERR", "Diameter: AAR failed on subscription to signalling\n");
			send_reply("403", "Can't register to QoS for signalling");
			exit;
	}
	# Proceed with Registering:
	route(REGISTER_CONTINUE);
}

route[REGISTER_CONTINUE] {
#!endif
	append_hf("Path: <sip:term@HOSTNAME;lr>\r\n");

	remove_hf("Supported");
	append_hf("Supported: path\r\n");
	remove_hf("Require");
	append_hf("Require: path\r\n");

	# Add a visited Network-ID-Header:
	if (is_present_hf("P-Visited-Network-ID")) {
		$var(new_hdr) = "NETWORKNAME, "+$hdr(P-Visited-Network-ID);
		append_hf("P-Visited-Network-ID: $var(new_hdr)\r\n");
	} else {
		append_hf("P-Visited-Network-ID: NETWORKNAME\r\n");
	}
#!ifdef WITH_SBC
#!ifndef WITH_SBC_CALL
	t_on_failure("SBC_failure");
	# Choose an SBC to send the call to:
	if (!ds_select_dst(DISPATCHER_LIST_SBC, "4")) {
		send_reply("503", "Service Unavailable (SBC failure)");
		exit;
	}
#!else
	t_on_failure("REGISTER_failure");
#!endif
#!else
	t_on_failure("REGISTER_failure");
#!endif
	t_on_reply("REGISTER_reply");
	# Forward request:
	route(RELAY);
	exit;
}

# Replies for REGISTER requests:
######################################################################
onreply_route[REGISTER_reply]
{
#!ifdef WITH_IMS_HDR_CACHE
	if (is_present_hf("Service-Route")) {
		$sht(serviceroutes=>$ci) = $hdr(Service-Route);
	} else {
		if ($sht(serviceroutes=>$ci) != $null) {
			append_hf("Service-Route: $sht(serviceroutes=>$ci)\r\n");
			msg_apply_changes();
		}
	}
	if (is_present_hf("P-Associated-URI")) {
		$sht(associateduris=>$ci) = $hdr(P-Associated-URI);
	} else {
		if ($sht(associateduris=>$ci) != $null) {
			append_hf("P-Associated-URI: $sht(associateduris=>$ci)\r\n");
			msg_apply_changes();
		}
	}
#!endif

	if (t_check_status("200")) {
#!ifdef WITH_IPBLOCK
		$sht(failedauth=>$T_req($si)) = $null;
#!endif
		pcscf_save("location");

#!ifdef WITH_NATPING
#!ifdef WITH_PING_UDP
		#if ($T_req($pr) == "udp") {
		if ($pr == "udp") {
			sht_lock("natping=>natpinglock");
			if ($(T_req($hdr(Security-Client))) =~ ".*ipsec-3gpp.*") {
				$var(sec_client) = $(T_req($hdr(Security-Client)));
				xnotice("Security-Client=$var(sec_client)\n");
				$var(sc_port_c) = $(var(sec_client){re.subst,/.*port-c=([0-9]*).*$/\1/s});
				xnotice("port-c=$var(sc_port_c)\n");
				$var(sc_port_s) = $(var(sec_client){re.subst,/.*port-s=([0-9]*).*$/\1/s});
				xnotice("port-s=$var(sc_port_s)\n");
				$var(ouri) = "sip:"+$T_req($si)+":"+$var(sc_port_s);
			} else {
				$var(ouri) = "sip:"+$T_req($si)+":"+$T_req($sp);
			}
			$sht(natping=>$var(ouri)) = $(T_req($ct){nameaddr.uri});
			sht_unlock("natping=>natpinglock");

			sht_lock("natpingfrom=>natpingfromlock");
			if ($(T_req($hdr(Security-Verify))) =~ ".*ipsec-3gpp.*") {
				$var(sec_verify) = $(T_req($hdr(Security-Verify)));
				xnotice("Security-Verify=$var(sec_verify)\n");
				$var(sv_port_c) = $(var(sec_verify){re.subst,/.*port-c=([0-9]*).*$/\1/s});
				xnotice("port-c=$var(sv_port_c)\n");
				$var(sv_port_s) = $(var(sec_verify){re.subst,/.*port-s=([0-9]*).*$/\1/s});
				xnotice("port-s=$var(sv_port_s)\n");

				$sht(natpingfrom=>$var(ouri)) = "udp:"+$T_req($Ri)+":"+$var(sv_port_c);
			} else {
				$sht(natpingfrom=>$var(ouri)) = "udp:"+$T_req($Ri)+":"+$T_req($Rp);
			}
			sht_unlock("natpingfrom=>natpingfromlock");
		}
#!endif
#!ifdef WITH_PING_TCP
		#if ($T_req($pr) == "tcp") {
		if ($pr == "tcp") {
			sht_lock("natping=>natpinglock");
			if ($(T_req($hdr(Security-Client))) =~ ".*ipsec-3gpp.*") {
				$var(sec_client) = $(T_req($hdr(Security-Client)));
				xnotice("Security-Client=$var(sec_client)\n");
				$var(sc_port_c) = $(var(sec_client){re.subst,/.*port-c=([0-9]*).*$/\1/s});
				xnotice("port-c=$var(sc_port_c)\n");
				$var(sc_port_s) = $(var(sec_client){re.subst,/.*port-s=([0-9]*).*$/\1/s});
				xnotice("port-s=$var(sc_port_s)\n");
				$var(ouri) = "sip:"+$T_req($si)+":"+$var(sc_port_s)+";transport=tcp";
			} else {
				$var(ouri) = "sip:"+$T_req($si)+":"+$T_req($sp)+";transport=tcp";
			}
			$sht(natping=>$var(ouri)) = $(T_req($ct){nameaddr.uri});
			sht_unlock("natping=>natpinglock");

			sht_lock("natpingfrom=>natpingfromlock");
			if ($(T_req($hdr(Security-Verify))) =~ ".*ipsec-3gpp.*") {
				$var(sec_verify) = $(T_req($hdr(Security-Verify)));
				xnotice("Security-Verify=$var(sec_verify)\n");
				$var(sv_port_c) = $(var(sec_verify){re.subst,/.*port-c=([0-9]*).*$/\1/s});
				xnotice("port-c=$var(sv_port_c)\n");
				$var(sv_port_s) = $(var(sec_verify){re.subst,/.*port-s=([0-9]*).*$/\1/s});
				xnotice("port-s=$var(sv_port_s)\n");

				$sht(natpingfrom=>$var(ouri)) = "tcp:"+$T_req($Ri)+":"+$var(sv_port_c);
			} else {
				$sht(natpingfrom=>$var(ouri)) = "tcp:"+$T_req($Ri)+":"+$T_req($Rp);
			}
			sht_unlock("natpingfrom=>natpingfromlock");
		}
#!endif
#!ifdef WITH_PING_TLS
		#if ($T_req($pr) == "tls") {
		if ($pr == "tls") {
			sht_lock("natping=>natpinglock");
			if ($(T_req($hdr(Security-Client))) =~ ".*ipsec-3gpp.*") {
				$var(sec_client) = $(T_req($hdr(Security-Client)));
				xnotice("Security-Client=$var(sec_client)\n");
				$var(sc_port_c) = $(var(sec_client){re.subst,/.*port-c=([0-9]*).*$/\1/s});
				xnotice("port-c=$var(sc_port_c)\n");
				$var(sc_port_s) = $(var(sec_client){re.subst,/.*port-s=([0-9]*).*$/\1/s});
				xnotice("port-s=$var(sc_port_s)\n");
				$var(ouri) = "sip:"+$T_req($si)+":"+$var(sc_port_s)+";transport=tls";
			} else {
				$var(ouri) = "sip:"+$T_req($si)+":"+$T_req($sp)+";transport=tls";
			}
			$sht(natping=>$var(ouri)) = $(T_req($ct){nameaddr.uri});
			sht_unlock("natping=>natpinglock");

			sht_lock("natpingfrom=>natpingfromlock");
			if ($(T_req($hdr(Security-Verify))) =~ ".*ipsec-3gpp.*") {
				$var(sec_verify) = $(T_req($hdr(Security-Verify)));
				xnotice("Security-Verify=$var(sec_verify)\n");
				$var(sv_port_c) = $(var(sec_verify){re.subst,/.*port-c=([0-9]*).*$/\1/s});
				xnotice("port-c=$var(sv_port_c)\n");
				$var(sv_port_s) = $(var(sec_verify){re.subst,/.*port-s=([0-9]*).*$/\1/s});
				xnotice("port-s=$var(sv_port_s)\n");

				$sht(natpingfrom=>$var(ouri)) = "tls:"+$T_req($Ri)+":"+$var(sv_port_c);
			} else {
				$sht(natpingfrom=>$var(ouri)) = "tls:"+$T_req($Ri)+":"+$T_req($Rp);
			}
			sht_unlock("natpingfrom=>natpingfromlock");
		}
#!endif
#!endif
		#update stats for register reply on success
		$var(start_secs) = $(sht(a=>$ci::start_time){s.select,0,.});
		$var(start_usecs) = $(sht(a=>$ci::start_time){s.select,1,.});
		$var(diff_secs) = $TV(s) - $var(start_secs);
		$var(diff_usecs) = $TV(u) - $var(start_usecs);
		$var(diff_ms) = $var(diff_secs)*1000 + ($var(diff_usecs)/1000);
		$sht(a=>$ci::start_time)=0;
		$var(stat_add) = "+" + $var(diff_ms);
		xlog("L_DBG", "REGISTER SUCCESS[$ci] took $var(stat_add)ms\n");
		update_stat("register_success", "+1");
		update_stat("register_time", "$var(stat_add)");
#!ifdef WITH_IPSEC
            ipsec_forward("location", IPSEC_FORWARD_FLAGS);
   	}
	else {
		if (t_check_status("401")) {
			if($(T_req($hdr(Security-Client))) != $null && ipsec_create("location", IPSEC_DELETE_UNUSED_TUNNELS)!=1) {
				send_reply("503", "Service Unavailable (Create ipsec failed)");
			}
			if ($sht(ipsec_clients=>$(T_req($ct){nameaddr.uri})) != $null) {
				$var(sec_client) = $(T_req($hdr(Security-Client)));
				xnotice("Security-Client=$var(sec_client)\n");
				$var(sc_port_c) = $(var(sec_client){re.subst,/.*port-c=([0-9]*).*$/\1/s});
				xnotice("port-c=$var(sc_port_c)\n");
				$var(sc_port_s) = $(var(sec_client){re.subst,/.*port-s=([0-9]*).*$/\1/s});
				xnotice("port-s=$var(sc_port_s)\n");
			}
			xnotice("Expires=$(T_req($expires(min)))\n");
			if (is_present_hf("WWW-Authenticate")) {
				# Remove ck and ik:
				$var(old_hdr) = $hdr(WWW-Authenticate);
				xnotice("Old header - WWW-Authenticate=$var(old_hdr)\n");
				remove_hf("WWW-Authenticate");
				$var(new_hdr) = $(hdr(WWW-Authenticate){re.subst,/(, *)?(ck|ik)=\"\w+\"//gi});
				if ($(var(new_hdr){s.len}) > 0) {
					append_hf("WWW-Authenticate: $var(new_hdr)\r\n");
				}
				xnotice("New header - WWW-Authenticate=$var(new_hdr)\n");
			}
        }
#!endif
    }
	exit;
}

# Negative replies to REGISTER requests:
######################################################################
failure_route[REGISTER_failure]
{
#!ifdef WITH_IPBLOCK
	if (t_check_status("403|[5-6][0-9][0-9]")) {
		if ($sht(failedauth=>$si) != $null)
			$sht(failedauth=>$si) = $sht(failedauth=>$si) + 1;
		else
			$sht(failedauth=>$si) = 1;
		if ($sht(failedauth=>$si) > 10) {
			xlog("L_ALERT","ALERT: blocking $rm from $fu (IP:$si:$sp), more than 5 failed auth requests!\n");
			xlog("Blocking traffic from $si\n");
			$sht(ipban=>$si) = 1;
		}
                update_stat("register_failed", "+1");
	}
#!endif
	if (t_check_status("408")) {
		send_reply("504","Server Time-Out");
                update_stat("register_failed", "+1");
		exit;
	}
}

# RTPProxy control
route[ENC_SRTP] {
	add_rr_param(";rm=1");
	$avp(rtpproxy_offer_flags) = "flags=loop-protect replace-origin replace-session-connection ICE=force SRTP AVP";
	$avp(rtpproxy_answer_flags) = "flags=loop-protect replace-origin replace-session-connection ICE=remove RTP AVP";
}

route[DEC_SRTP] {
	add_rr_param(";rm=2");
	$avp(rtpproxy_offer_flags) = "flags=loop-protect replace-origin replace-session-connection ICE=remove RTP AVP";
	$avp(rtpproxy_answer_flags) = "flags=loop-protect replace-origin replace-session-connection ICE=force SRTP AVP";
}

route[ENC_WS_RTP] {
	add_rr_param(";rm=3");
	$avp(rtpproxy_offer_flags) = "flags=loop-protect replace-origin replace-session-connection ICE=force RTP AVPF";
	$avp(rtpproxy_answer_flags) = "flags=loop-protect replace-origin replace-session-connection ICE=remove RTP AVP";
}

route[DEC_WS_RTP] {
	add_rr_param(";rm=4");
	$avp(rtpproxy_offer_flags) = "flags=loop-protect replace-origin replace-session-connection ICE=remove RTP AVP";
	$avp(rtpproxy_answer_flags) = "flags=loop-protect replace-origin replace-session-connection ICE=force RTP AVPF";
}

route[ENC_WSS_RTP] {
	add_rr_param(";rm=5");
	$avp(rtpproxy_offer_flags) = "flags=loop-protect replace-origin replace-session-connection ICE=force SRTP AVPF DTLS=passive";
	$avp(rtpproxy_answer_flags) = "flags=loop-protect replace-origin replace-session-connection ICE=remove RTP AVP";
}

route[DEC_WSS_RTP] {
	add_rr_param(";rm=6");
	$avp(rtpproxy_offer_flags) = "flags=loop-protect replace-origin replace-session-connection ICE=remove RTP AVP";
	$avp(rtpproxy_answer_flags) = "flags=loop-protect replace-origin replace-session-connection ICE=force SRTP AVPF DTLS=passive";
}

route[ENC_RTP] {
	add_rr_param(";rm=7");
	$avp(rtpproxy_offer_flags) = "flags=loop-protect replace-origin replace-session-connection ICE=force RTP AVP";
	$avp(rtpproxy_answer_flags) = "flags=loop-protect replace-origin replace-session-connection ICE=remove RTP AVP";
}

route[DEC_RTP] {
	add_rr_param(";rm=8");
	$avp(rtpproxy_offer_flags) = "flags=loop-protect replace-origin replace-session-connection ICE=remove RTP AVP";
	$avp(rtpproxy_answer_flags) = "flags=loop-protect replace-origin replace-session-connection ICE=force RTP AVP";
}

# RTPProxy control
route[NATMANAGE] {
#!ifdef WITH_DEBUG
	if (is_request())
		xlog("REQUEST: $rm $ru ($si:$sp, $ci)\n");
	else
		xlog("REPLY: $rs $rr ($rm, $si:$sp, $ci)\n");

	if (is_direction("downstream"))
		xlog("    downstream\n");
	else
		xlog("    upstream\n");

	xlog("    Offer: $avp(rtpproxy_offer_flags)\n");
	xlog("    Answer: $avp(rtpproxy_answer_flags)\n");
	if (isflagset(FLT_MOBILE_ORIG)) {
		xlog("    mo\n");
	} else {
		xlog("    mt\n");
	}
#!endif
	if ((is_reply() && ($T_req($tt) != $null)) || (is_request() && has_totag())) {
		xlog("L_DBG", "Request had ToTag.");
		#if((is_request() && !check_route_param("rm=")) || (is_reply() && !isflagset(FLT_RTP))) {
		if(!check_route_param("rm=") && !isflagset(FLT_RTP)) {
			xlog("L_DBG", "No RM Param\n");
			return;
		}
		if (($fU != $null && is_in_profile("caller", "$fU")) ||
			($tU != $null && is_in_profile("callee", "$tU"))) {
			# In-Dialog Request from MO side
			if (is_request() && isflagset(FLT_MOBILE_ORIG)) {
				add_contact_alias();
			} else if (is_reply() && !isflagset(FLT_MOBILE_ORIG)) {
				add_contact_alias();
			}
		} else if (($fU != $null && is_in_profile("callee", "$fU")) ||
			($tU != $null && is_in_profile("caller", "$tU"))) {
			# In-Dialog Request from MT side
			if (is_request() && !isflagset(FLT_MOBILE_ORIG)) {
				add_contact_alias();
			} else if (is_reply() && isflagset(FLT_MOBILE_ORIG)) {
				add_contact_alias();
			}
		}
	} else {
		if (is_reply() && !isflagset(FLT_MOBILE_ORIG)) {
			xlog("L_DBG", "3) ADD_contact_alias();");
			add_contact_alias();
		}
	}

	if (isflagset(FLT_MOBILE_ORIG)) {
		$avp(setid) = 1;
		$avp(extra_id) = "mo";
	} else {
		$avp(setid) = 1;
#		$avp(setid) = 2;
		$avp(extra_id) = "mt";
	}

	if(!t_is_set("onreply_route")) t_on_reply("NAT_REPLY");
	if(!t_is_set("failure_route")) t_on_failure("NATMANAGE");

	if (is_method("BYE") || t_is_failure_route()) {
		rtpengine_manage();
		return;
	}

	setflag(FLT_RTP);

	if (!has_body("application/sdp"))
		return;

#!ifdef REMOVE_BITALIGNED_AMR
	route(REMOVE_BITALIGNED);
#!endif

#!ifndef FORCE_RTPRELAY
	if (!isflagset(FLT_NAT) || !check_route_param("rm="))
		return;
#!endif

	# Fix for calling between UEs not supporting preconditioning
	if(sdp_get_line_startswith("$avp(mline)", "a=inactive")) {
		xlog("m-line: $avp(mline)\n");
		sdp_remove_line_by_prefix("a=inactive");
		$sdp(body) = $sdp(body) + "a=sendrecv\r\n";
		msg_apply_changes();
	}

	if ((is_reply() && ($T_req($tt) != $null)) || (is_request() && has_totag())) {
		if (($fU != $null && is_in_profile("caller", "$fU")) ||
			($tU != $null && is_in_profile("callee", "$tU"))) {
			# In-Dialog Request from MO side
			if (is_request() && isflagset(FLT_MOBILE_ORIG)) {
				rtpengine_manage();
			} else if (is_reply() && !isflagset(FLT_MOBILE_ORIG)) {
				rtpengine_manage();
			}
		} else if (($fU != $null && is_in_profile("callee", "$fU")) ||
			($tU != $null && is_in_profile("caller", "$tU"))) {
			# In-Dialog Request from MT side
			if (is_request() && !isflagset(FLT_MOBILE_ORIG)) {
				rtpengine_manage();
			} else if (is_reply() && isflagset(FLT_MOBILE_ORIG)) {
				rtpengine_manage();
			}
		}
	} else {
		# Initial Requests
		if ($avp(rtpproxy_offer_flags) == $null)
			return;
		if ($avp(rtpproxy_answer_flags) == $null)
			return;

		if (is_request() && isflagset(FLT_MOBILE_ORIG)) {
			set_dlg_profile("caller", "$fU");
			rtpengine_manage($avp(rtpproxy_offer_flags));
		} else if (is_reply() && !isflagset(FLT_MOBILE_ORIG)) {
			set_dlg_profile("callee", "$tU");
			rtpengine_manage($avp(rtpproxy_answer_flags));
		}
	}
}

# manage incoming replies
onreply_route[NAT_REPLY] {
	# In case of 1xx and 2xx do NAT
	if(status=~"[12][0-9][0-9]")
		route(NATMANAGE);
}

route[REMOVE_BITALIGNED] {
	if (sdp_get_line_startswith("$avp(mline)", "m=")) {
		# xlog("m-line: $avp(mline)\n");
		sdp_get("$avp(sdp)");
		# xlog("\n$avp(sdp)\n");
		$var(x) = -1;
		$var(remove) = "";
		$var(codec) = $(avp(mline){s.select,$var(x), });
		# xlog("$$var(codec) => $var(codec)\n");
		while ($(var(codec){s.int}) > 0) {
			# xlog("$var(x)) $$var(codec) => $var(codec)\n");
			$var(s) = "a=fmtp:"+$var(codec);
			# xlog("$$var(s) => $var(s)\n");
			$var(fmtp) = $(avp(sdp){line.sw,$var(s)});
			# xlog("$$var(fmtp) => $var(fmtp)\n");
			if ($var(fmtp) =~ "a=fmtp:"+$var(codec)+" mode-change-capability.*") {
				# xlog("Match: $var(codec)\n");
				if ($var(remove) == "") {
					$var(remove) = $var(codec);
				} else {
					$var(remove) = $var(remove)+","+$var(codec);
				}
			}
			$var(codec) = $(avp(mline){s.select,$var(x), });
			$var(x) = $var(x) - 1;
		}
		# xlog("$$var(remove) => $var(remove)\n");
		if ($var(remove) != "") {
			sdp_remove_codecs_by_id($var(remove), "audio");
			msg_apply_changes();
		}
	}
}


######################################################################
# Originating, Intial Requests
######################################################################
route[MO]
{
	# Strip Transport from RURI:
	$ru = $(ru{re.subst,/;transport=[A-Za-z]*//g});
	xnotice("PCSCF MO: \n Destination URI: $du\n Request URI: $ru\n");
    xnotice("Source IP and Port: ($si:$sp)\n Route-URI: $route_uri\n");
    xnotice("Received IP and Port: ($Ri:$Rp)\n");
    xnotice("Contact header: $ct\n");

	# Process route headers, if any:
	loose_route();
	if (!pcscf_is_registered("location")) {
		send_reply("403","Forbidden - You must register first with a S-CSCF");
		exit;
	}

	# We do not trust the user, let's remove the P-Asserted-Identity, if any:
	remove_hf("P-Asserted-Identity");
	remove_hf("P-Preferred-Identity");

	# Add P-Charging-Vector
	sip_p_charging_vector("g");

	if (is_present_hf("P-Preferred-Identity") && pcscf_assert_identity("location", "$hdr(P-Preferred-Identity)") && $hdr(P-Preferred-Identity) =~ "sip:.*") {
		append_hf("P-Asserted-Identity: $hdr(P-Preferred-Identity)\r\n");
	} else if (is_present_hf("P-Asserted-Identity") && pcscf_assert_identity("location", "$hdr(P-Asserted-Identity)") && $hdr(P-Asserted-Identity) =~ "sip:.*") {
		append_hf("P-Asserted-Identity: $hdr(P-Asserted-Identity)\r\n");
	} else if (pcscf_assert_identity("location", "$(fu{tobody.uri})")) {
		# For broken SIP implementation in Samsung devices
		if ($fu =~ "tel:.*") {
			$var(new_hdr) = $(fu{tobody.uri}) + "@NETWORKNAME";
			$var(new_hdr) = $(var(new_hdr){re.subst,/tel:/sip:/g});
			append_hf("P-Asserted-Identity: <$var(new_hdr)>\r\n");
			$fu = $var(new_hdr);
		} else {
			append_hf("P-Asserted-Identity: <$(fu{tobody.uri})>\r\n");
		}
	} else {
		append_hf("P-Asserted-Identity: <$pcscf_asserted_identity>\r\n");
	}

	if (!pcscf_follows_service_routes("location")){
		#Variant 1 - deny access to the network
		#send_reply("400","Bad Request - Not following indicated service routes");
		#break;

		#Variant 2 - enforce routes and let the dialog continue
		pcscf_force_service_routes("location");
	}

	# add IBCF/THIG route here if required
	# Check for "sec-agree" in the Require header:
	if (is_present_hf("Require") && $hdr(Require) =~ ".*sec-agree.*") {
		# Remove the old Require-Header:
		remove_hf("Require");
		# Replace ", sec-agree" with ""
		$var(new_hdr) = $(hdr(Require){re.subst,/[, ]*sec-agree//gi});
		if ($(var(new_hdr){s.len}) > 0) {
			append_hf("Require: $var(new_hdr)\r\n");
		}
	}

	# Check for "sec-agree" in the Proxy-Require header:
	if (is_present_hf("Proxy-Require") && $hdr(Proxy-Require) =~ ".*sec-agree.*") {
		# Remove the old Proxy-Require-Header:
		remove_hf("Proxy-Require");
		# Replace ", sec-agree" with ""
		$var(new_hdr) = $(hdr(Proxy-Require){re.subst,/[, ]*sec-agree//gi});
		if ($(var(new_hdr){s.len}) > 0) {
			append_hf("Proxy-Require: $var(new_hdr)\r\n");
		}
        }
	remove_hf("Security-Verify");

#!ifdef TRF_FUNCTION
	$var(trf) = TRF_FUNCTION;
	# Check for "sec-agree" in the Proxy-Require header:
	if (is_present_hf("Feature-Caps")) {
		# Remove the old Proxy-Require-Header:
		remove_hf("Feature-Caps");
		append_hf("Feature-Caps: $hdr(Feature-Caps);+g.3gpp.trf=\"<sip:$var(trf);lr>\"\r\n");
        } else {
		append_hf("Feature-Caps: *;+g.3gpp.trf=\"<sip:$var(trf);lr>\"\r\n");
	}
#!endif
	# Add a visited Network-ID-Header:
	if (is_present_hf("P-Visited-Network-ID")) {
		$var(new_hdr) = "NETWORKNAME, "+$hdr(P-Visited-Network-ID);
		append_hf("P-Visited-Network-ID: $var(new_hdr)\r\n");
	} else {
		append_hf("P-Visited-Network-ID: NETWORKNAME\r\n");
	}
	set_dlg_profile("orig");
	t_on_reply("MO_reply");
}

######################################################################
# Replies to Originating Initial Requests
######################################################################
onreply_route[MO_reply] {
	xnotice("PCSCF MO_reply: \n Destination URI: $du\n Request URI: $ru\n");
    xnotice("Source IP and Port: ($si:$sp)\n Route-URI: $route_uri\n");
    xnotice("Received IP and Port: ($Ri:$Rp)\n");
    xnotice("Contact header: $ct\n");
	if (is_present_hf("C-Params")) {
		remove_hf("Contact");
		remove_hf("C-Params");
		append_hf("Contact: $ct;$hdr(C-Params)\r\n");
	}
#!ifdef WITH_IPSEC
	ipsec_forward("location", IPSEC_FORWARD_FLAGS);
#!endif
	# In case of 1xx and 2xx do NAT
	if(status=~"[12][0-9][0-9]")
		route(NATMANAGE);
#!ifdef WITH_RX
        if (t_check_status("183|200") && has_body("application/sdp")){
		xlog("L_DBG", "IMS: Received 183/200 inside orig_initial_reply\n");

		if (t_is_retr_async_reply()) {
	                xlog("L_DBG", "Dropping retransmitted reply which is still currently suspended\n");
                	drop();
	        }

		xlog("L_DBG","Diameter: Orig authorizing media via Rx\n");
		$avp(FTAG_CUSTOM_AVP)=$ft;
		$avp(TTAG_CUSTOM_AVP)=$tt;
		$avp(CALLID_CUSTOM_AVP)=$ci;

        if (Rx_AAR("MO_aar_reply","orig","",-1) == 0) {
            exit;
        }
	}
}

route[MO_aar_reply]
{
        #this is async so to know status we have to check the reply avp
	switch ($avp(s:aar_return_code)) {
		case 1:
			xlog("L_DBG", "Diameter: Orig AAR success on media authorization\n");
			break;
		default:
			xlog("L_ERR", "IMS: AAR failed Orig\n");
               		xlog("L_ERR", "IMS: ttag: "+ "$avp(TTAG_CUSTOM_AVP)");
	                xlog("L_ERR", "IMS: ftag: "+ "$avp(FTAG_CUSTOM_AVP)");
	                xlog("L_ERR", "IMS: callid: "+ "$avp(CALLID_CUSTOM_AVP)");
			#comment this if you want to allow even if Rx fails
	                if(dlg_get("$avp(CALLID_CUSTOM_AVP)","$avp(FTAG_CUSTOM_AVP)","$avp(TTAG_CUSTOM_AVP)")){
                        	dlg_terminate("all", "Sorry no QoS available");
                       		exit;
               		}
	}
#!endif
}


######################################################################
# In-Dialog-Mo-Requests
######################################################################
route[MO_indialog] {
	xnotice("PCSCF MO_indialog: \n Destination URI: $du\n Request URI: $ru\n");
    xnotice("Source IP and Port: ($si:$sp)\n Route-URI: $route_uri\n");
    xnotice("Received IP and Port: ($Ri:$Rp)\n");
    xnotice("Contact header: $ct\n");
	setflag(FLT_MOBILE_ORIG);
	t_on_reply("MO_indialog_reply");

	# Append rport only if its a request coming from UE
	if (is_request() && ($hdrc(Via) == 1)) {
		force_rport();
	}

#!ifdef WITH_IPSEC
	if ($dd != "" && $rd != "" && $fs != "") {
        if ($rd =~ ".*" + $dd + ".*") {
			ipsec_forward("location", IPSEC_FORWARD_FLAGS);
		}
	}
#!endif
}

onreply_route[MO_indialog_reply] {
	xnotice("PCSCF MO_indialog_reply: \n Destination URI: $du\n Request URI: $ru\n");
    xnotice("Source IP and Port: ($si:$sp)\n Route-URI: $route_uri\n");
    xnotice("Received IP and Port: ($Ri:$Rp)\n");
    xnotice("Contact header: $ct\n");

	# In case of 1xx and 2xx do NAT
	if(status=~"[12][0-9][0-9]")
		route(NATMANAGE);

#!ifdef WITH_RX
	if (t_check_status("183|200") && has_body("application/sdp") && !is_method("PRACK")) {
		if (t_is_retr_async_reply()) {
	                xlog("L_DBG", "Dropping retransmitted reply which is still currently suspended\n");
       	         	drop();
        	}

      		xlog("L_DBG", "IMS: ORIG_SUBSEQUENT reply. This is a 200 OK to a re-INVITE\n");
		xlog("L_DBG","Diameter: Orig authorizing media via Rx\n");
		$avp(FTAG_CUSTOM_AVP)=$ft;
		$avp(TTAG_CUSTOM_AVP)=$tt;
		$avp(CALLID_CUSTOM_AVP)=$ci;

		if (Rx_AAR("MO_indialog_aar_reply","orig","",-1) == 0) {
            exit;
        }
	}
}

route[MO_indialog_aar_reply]
{
        #this is async so to know status we have to check the reply avp
	switch ($avp(s:aar_return_code)) {
                case 1:
                        xlog("L_DBG", "Diameter: Orig AAR success on media authorization\n");
                        break;
                default:
                        xlog("L_ERR", "IMS: AAR failed Orig\n");
                        xlog("L_ERR", "IMS: ttag: "+ "$avp(TTAG_CUSTOM_AVP)");
                        xlog("L_ERR", "IMS: ftag: "+ "$avp(FTAG_CUSTOM_AVP)");
                        xlog("L_ERR", "IMS: callid: "+ "$avp(CALLID_CUSTOM_AVP)");
			#comment this if you want to allow even if Rx fails
                        if(dlg_get("$avp(CALLID_CUSTOM_AVP)","$avp(FTAG_CUSTOM_AVP)","$avp(TTAG_CUSTOM_AVP)")){
                                dlg_terminate("all", "Sorry no QoS available");
                                exit;
                        }
        }
#!endif
}

######################################################################
# Terminating, Initial requests
######################################################################
route[MT] {
    xnotice("PCSCF MT: \n Destination URI: $du\n Request URI: $ru\n");
    xnotice("Source IP and Port: ($si:$sp)\n Route-URI: $route_uri\n");
    xnotice("Received IP and Port: ($Ri:$Rp)\n");
    xnotice("Contact header: $ct\n");
    set_dlg_profile("term");
#!ifdef WITH_IPSEC
    ipsec_forward("location", IPSEC_FORWARD_FLAGS);
#!endif
	t_on_reply("MT_reply");
}

######################################################################
# Replies to Originating Initial Requests
######################################################################
onreply_route[MT_reply] {
    xnotice("PCSCF MT_reply: \n Destination URI: $du\n Request URI: $ru\n");
    xnotice("Source IP and Port: ($si:$sp)\n Route-URI: $route_uri\n");
    xnotice("Received IP and Port: ($Ri:$Rp)\n");
    xnotice("Contact header: $ct\n");
	if (!strempty($(ct{tobody.params}))) {
		append_hf("C-Params: $(ct{tobody.params})\r\n");
	}

	# In case of 1xx and 2xx do NAT
	if(status=~"[12][0-9][0-9]")
		route(NATMANAGE);
#!ifdef WITH_RX
        if (t_check_status("183|200") && has_body("application/sdp")){
        xnotice("PCSCF MT_reply: \n Destination URI: $du\n Request URI: $ru\n");
        xnotice("Source IP and Port: ($si:$sp)\n Route-URI: $route_uri\n");
        xnotice("Received IP and Port: ($Ri:$Rp)\n");
        xnotice("Contact header: $ct\n");
		xlog("L_DBG", "IMS: Received 183 inside term_initial_reply\n");

		xlog("L_DBG", "About to test if this is a retransmitted reply which is still currently suspended\n");
		if (t_is_retr_async_reply()) {
	                xlog("L_DBG", "Dropping retransmitted reply which is still currently suspended\n");
       		         drop();
       		}

		xlog("L_DBG","Diameter: Term authorizing media via Rx\n");
		$avp(FTAG_CUSTOM_AVP)=$ft;
		$avp(TTAG_CUSTOM_AVP)=$tt;
		$avp(CALLID_CUSTOM_AVP)=$ci;

        if (Rx_AAR("MT_aar_reply","term","",-1) == 0) {
            exit;
        }
	}
}

route[MT_aar_reply]
{
        xlog("L_DBG", "IMS: TERM_SESSION_AAR_REPLY\n");

        #this is async so to know status we have to check the reply avp
	switch ($avp(s:aar_return_code)) {
                case 1:
                        xlog("L_DBG", "Diameter: Orig AAR success on media authorization\n");
                        break;
                default:
                        xlog("L_ERR", "IMS: AAR failed Orig\n");
                        xlog("L_ERR", "IMS: ttag: "+ "$avp(TTAG_CUSTOM_AVP)");
                        xlog("L_ERR", "IMS: ftag: "+ "$avp(FTAG_CUSTOM_AVP)");
                        xlog("L_ERR", "IMS: callid: "+ "$avp(CALLID_CUSTOM_AVP)");
                        #comment this if you want to allow even if Rx fails
                        if(dlg_get("$avp(CALLID_CUSTOM_AVP)","$avp(FTAG_CUSTOM_AVP)","$avp(TTAG_CUSTOM_AVP)")){
                                dlg_terminate("all", "Sorry no QoS available");
                                exit;
                        }
        }
#!endif
}


######################################################################
# In-Dialog-MT-Requests
######################################################################
route[MT_indialog] {
    xnotice("PCSCF MT_indialog: \n Destination URI: $du\n Request URI: $ru\n");
    xnotice("Source IP and Port: ($si:$sp)\n Route-URI: $route_uri\n");
    xnotice("Received IP and Port: ($Ri:$Rp)\n");
    xnotice("Contact header: $ct\n");
    #resetflag(FLT_MOBILE_ORIG);
	t_on_reply("MT_indialog_reply");

    # Append rport only if its a request coming from UE
	if (is_request() && ($hdrc(Via) == 1)) {
		force_rport();
	}

#!ifdef WITH_IPSEC
    if ($dd != "" && $rd != "" && $fs != "") {
        if ($rd =~ ".*" + $dd + ".*") {
            ipsec_forward("location", IPSEC_FORWARD_FLAGS);
        }
    }
#!endif
}

onreply_route[MT_indialog_reply] {
    xnotice("PCSCF MT_indialog_reply: \n Destination URI: $du\n Request URI: $ru\n");
    xnotice("Source IP and Port: ($si:$sp)\n Route-URI: $route_uri\n");
    xnotice("Received IP and Port: ($Ri:$Rp)\n");
    xnotice("Contact header: $ct\n");
	# In case of 1xx and 2xx do NAT
	if(status=~"[12][0-9][0-9]")
		route(NATMANAGE);

#!ifdef WITH_RX
	if (t_check_status("183|200") && has_body("application/sdp") && !is_method("PRACK")) {
		if (t_is_retr_async_reply()) {
			xlog("L_DBG", "Dropping retransmitted reply which is still currently suspended\n");
			drop();
		}

		xlog("L_DBG", "IMS: TERM_SUBSEQUENT reply. This is a 200 OK to a re-INVITE\n");
		xlog("L_DBG","Diameter: Term authorizing media via Rx\n");
		$avp(FTAG_CUSTOM_AVP)=$ft;
		$avp(TTAG_CUSTOM_AVP)=$tt;
		$avp(CALLID_CUSTOM_AVP)=$ci;

		if (Rx_AAR("MT_indialog_aar_reply","term","",-1) == 0) {
            exit;
        }
	}
}

route[MT_indialog_aar_reply]
{
        #this is async so to know status we have to check the reply avp
	switch ($avp(s:aar_return_code)) {
                case 1:
                        xlog("L_DBG", "Diameter: Orig AAR success on media authorization\n");
                        break;
                default:
                        xlog("L_ERR", "IMS: AAR failed Orig\n");
                        xlog("L_ERR", "IMS: ttag: "+ "$avp(TTAG_CUSTOM_AVP)");
                        xlog("L_ERR", "IMS: ftag: "+ "$avp(FTAG_CUSTOM_AVP)");
                        xlog("L_ERR", "IMS: callid: "+ "$avp(CALLID_CUSTOM_AVP)");
                        #comment this if you want to allow even if Rx fails
                        if(dlg_get("$avp(CALLID_CUSTOM_AVP)","$avp(FTAG_CUSTOM_AVP)","$avp(TTAG_CUSTOM_AVP)")){
                                dlg_terminate("all", "Sorry no QoS available");
                                exit;
                        }
        }
#!endif
}


